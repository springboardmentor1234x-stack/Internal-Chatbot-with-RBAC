Secure RAG chatbot with JWT authentication, role-based access control, and LLM integration 

RBAC rule enforcement
 # Rule 1: Deny by default
 # Rule 2: Get effective roles
 # Rule 3a: Allow-list from metadata(effective role == role match)
 # Rule 3b: Permission-based access
 # Rule 4: Admin override (admin can access all)
 # Rule 5: Role union (any matching role grants access)
 # Rule 6: Check for explicit deny (future enhancement)


Query normalization
1- lowercase
2- regrex cleaned
3- tokenization
4- abbrevations expansion based on dataset (Expand quarter ranges (Q1-Q3 -> Q1 Q2 Q3))
5- stopword removal
6- n-gram generation
7- Extract important domain-specific terms


 Retrieval Pipeline
 # Step 1: Query Normalization and rewrite
 # Step 2: Generate query variants
 # Step 3: RBAC role resolution and permissions and rbac filtering
 # Step 4: Vector Retrieval results (candidate KNN) (chunk+score)
 # Step 5: Re-ranking and Deduplication(document level) and then thresholding 
 # Step 7: Final Results top k


output format:-
role
effective role(accessible role)
query variant
count of allowed chunk after rbac filtering
top k chunks
chunk id document source text score


FAST API
Setup FastAPI project structure
Run server successfully
Install dependencies
Create main.py
Create JWT access token
Create JWT refresh token
Decode and validate JWT token
Extract user information from token
Validate refresh token and extract user info
Swagger UI

JWT contains -> subject(username) role type token


MIDDLEWARE
authentication and authorization (user,role,permissions,resource)
1- request
2- jwt token
3- rbac chunks
4- business logic
5- data filtering
6- response
rbac before business logic
user role from jwt token
jwt structure 
header- metadata , algorithm
payload 
signature
subject(username)
role
expire
type of user

SQLlite
1- install dependencies
2- database.py - configuration base class
3- defining model (role.py) and user model- user.py->role validation compulsory 
4- creating table init db (install dependencies realated to SQL lite)

RBAC applied Twice - one at data level and other at api level
authentication once and authorization every time


client->post method(data login)->userdb(SQLLite)->password verification->jwt token (access+refresh)-> jwt validation-> rbac chunk-> retrieval pipeline->rbac filtering->top k

password hashed
disable user not active

Prompt
give one system message also
use simple language 
no repeated chunks
bullet point
RULES (MANDATORY):
- Use ONLY the provided context
- Do NOT guess, infer, or add external knowledge
- Do NOT reveal information from unauthorized departments
- If the answer is missing, say: "I don't have enough information in the accessible documents."
- Cite sources using [chunk_id]

ACCESS:
- Role: {role}
- Allowed Departments: {departments}

Be concise, factual, and professional.

user - jwt (access token +refresh token) - calls query + token - validate token(validate user+role) - rbac check (permission) - retrieval pipleline - prompt construction - llm generation

output by rag
user(username,role) + query input to rag+answer+source+chunk+confidence
format chunk before llm


RAG
1- rag orchestration function (doesn't know about fast api get authenticated user)
2- rbac gate
3- retrieval pipeline
4- handle empty pipeline
5- format chunk
6- prompt building- emphasis you prompt
7- call llm
8 - assemble all the things


SOURCE ATTRIBUTION
answer should givce source
source should come from retrieval pipeline (llm only write text)
document level attribution (ans and source from document or chunk)


final pipeline
1- client
2- post login API
3- jwt token
4- rag query authorization
5- jwt validation (authorized user)
6- api level rbac
7- retrieval pipeline
8- prompt construction
9- llm
10- response


